#Requires AutoHotkey v2.0
#SingleInstance Force

class RBTrayApp {
    static trayWindows := Map()
    static trayIcons := Map()
    static nextIconId := 1
    static debugMode := false  ; Set to true for debugging
    
    static __New() {
        ; Check for debug argument
        for arg in A_Args {
            if arg = "--debug" {
                this.debugMode := true
                break
            }
        }
        
        this.InitializeTray()
        this.InitializeMessageReceiver()
        this.InitializeHotkeys()
        
        if this.debugMode
            this.ShowDebugInfo()
    }
    
    static InitializeTray() {
        TraySetIcon("Shell32.dll", 16)
        A_IconTip := "RBTray - Win+Right-click to minimize to tray"
        
        A_TrayMenu.Delete()
        A_TrayMenu.Add("Show All Windows", (*) => this.RestoreAll())
        A_TrayMenu.Add()
        A_TrayMenu.Add("Exit RBTray", (*) => ExitApp())
    }
    
    static InitializeMessageReceiver() {
        ; Hidden GUI window to receive CLI messages (always create this)
        this.gui := Gui("+AlwaysOnTop -MaximizeBox -MinimizeBox", "RBTray")
        this.gui.Show("Hide")
        
        ; Create message window for CLI communication
        this.msgWin := Gui("-MaximizeBox -MinimizeBox", "RBTray_MessageWindow")
        this.msgWin.Add("Text", , "RBTray Message Receiver`nThis window receives CLI commands")
        
        ; Show or hide based on debug mode
        if this.debugMode {
            this.msgWin.Show("w350 h100")
        } else {
            ; Important: Show but make it invisible with 0x0 size, not "Hide"
            ; This ensures the window exists and can be found by RBTrayCmd
            this.msgWin.Show("w0 h0")
        }
        
        OnMessage(0x004A, ObjBindMethod(this, "ReceiveCommand"))
    }
    
    static InitializeHotkeys() {
        ; Keyboard shortcuts
        Hotkey("^+t", (*) => this.MinimizeToTray())
        Hotkey("^+r", (*) => this.RestoreAll())
        ; Exit handler
        OnExit((*) => this.RestoreAll())
    }
    
    static ShowDebugInfo() {
        ToolTip("RBTray started - HWND: " . this.gui.Hwnd . "`nClass: " . WinGetClass(this.gui.Hwnd))
        SetTimer(() => ToolTip(), -3000)
    }
    
    
    static IsValidWindow(hwnd) {
        try {
            style := WinGetStyle(hwnd)
            
            ; Basic visibility and caption check
            if !((style & 0x10000000) && (style & 0x00C00000))  ; WS_VISIBLE && WS_CAPTION
                return false
            
            ; Additional checks for problematic window types
            try {
                processName := WinGetProcessName(hwnd)
                className := WinGetClass(hwnd)
                
                ; Skip certain system processes that might cause issues
                if processName = "ApplicationFrameHost.exe" {
                    this.LogCommand("Skipping ApplicationFrameHost window: " . hwnd)
                    return false
                }
                
                ; Skip certain window classes that are known to be problematic
                if className = "Shell_TrayWnd" || className = "Shell_SecondaryTrayWnd" {
                    this.LogCommand("Skipping system tray window: " . hwnd)
                    return false
                }
            } catch {
                ; If we can't get process info, it might be a problematic window
                this.LogCommand("Cannot get window info for: " . hwnd . " - treating as invalid")
                return false
            }
            
            return true
        } catch {
            return false
        }
    }
    
    static MinimizeToTray(hwnd := "") {
        if !hwnd
            hwnd := WinExist("A")
        
        this.LogCommand("MinimizeToTray called with HWND: " . hwnd)
        
        if !hwnd {
            this.LogCommand("No window handle provided")
            return
        }
        
        if this.trayWindows.Has(hwnd) {
            this.LogCommand("Window already in tray: " . hwnd)
            return
        }
        
        try {
            windowData := this.CollectWindowData(hwnd)
            iconId := "RBTray_" . this.nextIconId++
            
            this.trayWindows[hwnd] := windowData
            this.trayWindows[hwnd].iconId := iconId
            
            this.CreateTrayIcon(hwnd, iconId, windowData.title, windowData.processPath)
            
            ; Try to hide the window with enhanced error handling
            try {
                WinHide(hwnd)
                this.LogCommand("Window hidden successfully: " . hwnd)
            } catch as hideError {
                this.LogCommand("Error hiding window " . hwnd . ": " . hideError.Message)
                ; Remove from tray since hide failed
                this.trayWindows.Delete(hwnd)
                if this.trayIcons.Has(iconId) {
                    try {
                        menuItem := this.trayIcons[iconId].menuItem
                        A_TrayMenu.Delete(menuItem)
                    } catch {
                    }
                    this.trayIcons.Delete(iconId)
                }
                return false
            }
        } catch as e {
            this.LogCommand("Error minimizing window: " . e.Message)
        }
    }
    
    static CollectWindowData(hwnd) {
        title := WinGetTitle(hwnd)
        processName := WinGetProcessName(hwnd)
        processPath := WinGetProcessPath(hwnd)
        className := WinGetClass(hwnd)
        pid := WinGetPID(hwnd)
        
        this.LogCommand("Window details - Title: " . title . ", Process: " . processName . ", Class: " . className . ", PID: " . pid)
        
        return {
            title: title,
            process: processName,
            processPath: processPath,
            className: className,
            pid: pid
        }
    }
    
    static CreateTrayIcon(hwnd, iconId, title, iconPath) {
        trayTip := title ? title : "Window"
        if StrLen(trayTip) > 64
            trayTip := SubStr(trayTip, 1, 61) . "..."
        
        A_TrayMenu.Insert("1&", trayTip, (*) => this.RestoreWindow(hwnd))
        
        try {
            A_TrayMenu.SetIcon(trayTip, iconPath)
        } catch {
            A_TrayMenu.SetIcon(trayTip, "Shell32.dll", 3)
        }
        
        this.trayIcons[iconId] := {
            hwnd: hwnd,
            menuItem: trayTip
        }
    }
    
    static RestoreWindow(hwnd) {
        if !this.trayWindows.Has(hwnd)
            return
        
        try {
            windowInfo := this.trayWindows[hwnd]
            
            if this.trayIcons.Has(windowInfo.iconId) {
                menuItem := this.trayIcons[windowInfo.iconId].menuItem
                try {
                    A_TrayMenu.Delete(menuItem)
                } catch {
                }
                this.trayIcons.Delete(windowInfo.iconId)
            }
            
            ; Try to show and activate the window with enhanced error handling
            try {
                WinShow(hwnd)
                this.LogCommand("Window shown successfully: " . hwnd)
            } catch as showError {
                this.LogCommand("Error showing window " . hwnd . ": " . showError.Message)
            }
            
            try {
                WinActivate(hwnd)
                this.LogCommand("Window activated successfully: " . hwnd)
            } catch as activateError {
                this.LogCommand("Error activating window " . hwnd . ": " . activateError.Message)
            }
            
            this.trayWindows.Delete(hwnd)
        } catch as e {
            this.LogCommand("Error restoring window: " . e.Message)
        }
    }
    
    static RestoreAll() {
        for hwnd, windowInfo in this.trayWindows.Clone() {
            this.RestoreWindow(hwnd)
        }
    }
    
    static ReceiveCommand(wParam, lParam, msg, hwnd) {
        try {
            this.LogCommand("ReceiveCommand called - wParam: " . wParam . ", lParam: " . lParam . ", msg: " . msg . ", hwnd: " . hwnd)
            command := this.ParseWMCopyData(lParam)
            this.LogCommand("Received command: " . command)
            
            if InStr(command, "hide:")
                this.ProcessHideCommand(SubStr(command, 6))
            else if command = "restore_all"
                this.RestoreAll()
            else if InStr(command, "restore:")
                this.ProcessRestoreCommand(SubStr(command, 9))
            else if command = "list"
                this.ProcessListCommand()
            else
                this.LogCommand("Unknown command: " . command)
            
            return true
        } catch as e {
            this.LogCommand("CRITICAL ERROR in ReceiveCommand: " . e.Message . " (Stack: " . e.Stack . ")")
            ; Don't let the error kill the message handler
            return false
        }
    }
    
    static ParseWMCopyData(lParam) {
        dataSize := NumGet(lParam, A_PtrSize, "UInt")
        dataPtr := NumGet(lParam, 2 * A_PtrSize, "Ptr")
        return StrGet(dataPtr, dataSize // 2, "UTF-16")
    }
    
    static ProcessHideCommand(target) {
        this.LogCommand("Processing hide command for: " . target)
        
        targetHwnd := this.FindTargetWindow(target)
        this.LogCommand("Found target window: " . targetHwnd)
        
        if targetHwnd {
            this.MinimizeToTray(targetHwnd)
            this.LogCommand("MinimizeToTray called for HWND: " . targetHwnd)
        } else {
            this.LogCommand("No window found for target: " . target)
        }
    }
    
    static ProcessRestoreCommand(target) {
        this.LogCommand("Processing restore command for: " . target)
        
        restoredCount := 0
        if InStr(target, "ahk_") {
            restoredCount := this.RestoreByAHKSelector(target)
        } else {
            restoredCount := this.RestoreByTitleOrProcess(target)
        }
        
        this.LogCommand("Restore command completed. Restored " . restoredCount . " windows.")
    }
    
    static ProcessListCommand() {
        list := ""
        for hwnd, windowInfo in this.trayWindows {
            list .= "HWND: " . hwnd . " | " . windowInfo.title . " | " . windowInfo.process . "`n"
        }
        
        if list {
            this.LogCommand("Hidden windows list:`n" . list)
        } else {
            this.LogCommand("No windows are currently hidden")
        }
    }
    
    static FindTargetWindow(target) {
        ; Check if target already has ahk_ prefix
        if InStr(target, "ahk_")
            return WinExist(target)
        
        ; Try common selectors, prioritize exe name
        targetHwnd := WinExist("ahk_exe " . target)
        if !targetHwnd
            targetHwnd := WinExist("ahk_class " . target)
        if !targetHwnd
            targetHwnd := WinExist(target)  ; Title matching
        
        return targetHwnd
    }
    
    static RestoreByAHKSelector(target) {
        this.LogCommand("Using AHK selector matching for: " . target)
        restoredCount := 0
        
        for hwnd, windowInfo in this.trayWindows.Clone() {
            if this.MatchesAHKSelector(target, hwnd, windowInfo) {
                this.LogCommand("Restoring window HWND: " . hwnd . " (" . windowInfo.title . ")")
                this.RestoreWindow(hwnd)
                restoredCount++
            }
        }
        
        return restoredCount
    }
    
    static RestoreByTitleOrProcess(target) {
        this.LogCommand("Using title/process matching for: " . target)
        restoredCount := 0
        
        for hwnd, windowInfo in this.trayWindows.Clone() {
            if InStr(windowInfo.title, target) || InStr(windowInfo.process, target) {
                this.LogCommand("Match found - Title: " . windowInfo.title . ", Process: " . windowInfo.process)
                this.RestoreWindow(hwnd)
                restoredCount++
            }
        }
        
        return restoredCount
    }
    
    static MatchesAHKSelector(target, hwnd, windowInfo) {
        if InStr(target, "ahk_exe ") {
            exeName := SubStr(target, 9)
            if InStr(windowInfo.process, exeName) {
                this.LogCommand("Match found by exe: " . exeName . " in " . windowInfo.process)
                return true
            }
        } else if InStr(target, "ahk_class ") {
            className := SubStr(target, 11)
            if windowInfo.className = className {
                this.LogCommand("Match found by stored class: " . className)
                return true
            }
        } else if InStr(target, "ahk_pid ") {
            targetPid := SubStr(target, 9)
            if windowInfo.pid = targetPid {
                this.LogCommand("Match found by stored PID: " . targetPid)
                return true
            }
        } else if InStr(target, "ahk_id ") {
            targetId := SubStr(target, 8)
            if hwnd = targetId {
                this.LogCommand("Match found by ID: " . targetId)
                return true
            }
        }
        return false
    }
    
    static LogCommand(message) {
        ; Log in debug mode OR when command line arguments are passed (for testing)
        if this.debugMode || A_Args.Length > 0 {
            FileAppend(A_Now . ": " . message . "`n", A_Temp . "\\RBTray_Commands.log")
        }
    }
}

; Initialize RBTray
RBTrayApp()

; Win+Right-click hotkey
#RButton::
{
    MouseGetPos(, , &hwnd)
    if hwnd && RBTrayApp.IsValidWindow(hwnd) {
        RBTrayApp.MinimizeToTray(hwnd)
        return
    }
    Send("{RButton}")
}